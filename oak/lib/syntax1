local: let std = import("std")

let my_module = mod:
  let list = mod:
    let T (A Type) = data
    | Cons(A, (T A))
    | Nil
    
    let T (A Type) = data
    | Cons(A, (T A))
    | Nil
    
    let empty = T.Cons
    
    let cons x xs = T.Cons(x, xs)
    
  let bruh = sig:
    let first Int
    
    let second Int
    
    type T Type
    
    type S Sig
    
    let third fun(Int, Int) Int
    
let first list.T = [1; 2; 3; 4; 5]

let second list.T:
  [1; 2; 3; 4; 5]

type my_alias A B = list.T(pair.T(A, B))

let first = fun[A Type, B Type](x A, y B, z Int):
  let first = 12341234
  let second = 1234324
  let third = 2134023948712304987
  
let my_alias = funct(A Type, B Type): list.T(pair.T(A, B))

let my_another = {
  let first = 13
  let second = 1234
  first + second
}

let Reader = sig:
  let Inner :: Type
    
  let T struct:
    buffer bytes
    mut position int
    inner Inner
  
  let read fun(T)
  
let Future sig:
  let T funct(Type) Type
  
  let await fun[A Type](T(A)) A
  let spawn fun[A Type](fun() A) T(A)
  
let Io = sig:
  let future Future
  
  let another funct(A type, B type) is(list.T(pair.T(A, B)), Type)
  
  let awefawef = tup(1, 2, 3)
  
  let another = tup(Int, bool, 3)
  
  let fs sig:
    let file sig:
      let T Type
      
      let open fun(string.T) T
      
      let to_reader fun(T) Reader
      
      let to_writer fun(T) Writer

    let dir sig:
      let T type
      
      let open fun(string.T) T
      
      let close fun(T) Unit
      
let Eq = sig {
  type K Kind
  
  type T func(K) Type
  
  let sexp_of_t func('k K @ 0, 'b type @ 0, T(k)) sexp.T
  
  let t_of_sexp func (k K) T -> T
}
  
(= (lambda(A type): A) func(type) type)

Is(|A type|: A, func(type) type)

let bruh(x, y, z) = list(pair(pair(x, y), z))

let another(x Int, y Int, z Int) Int:
  x + y + z
  
type show_pair(x show, y show) with(show, .T = pair(x.T, y.T)) = mod {
  type T = pair(x.T, y.T)
  
  let show(p) = show(fst(p)) ^ show(snd(p))
  }

let y square(int):
    pack mod:
    let x: 1234
    let y: 12342134
    
let x: |x Int, y Bool, z Type| Int:
    match x
    | first:
        1234234
    | second:
        1341234
    
    x + y + z

type x(x, y, z) = 12341234

let my_function(another)
  x + y + z

type my_function(another)
  x + y + z

let my_function(x Int, y Int, z Bool):
    x + y + z + 1234234

let x: |x, y, z|:
    x + y + z
    
let z: |x type, 'x type, 'y type, type z, z : int|:
    x + y + z
    
let w: ||x, z, w||:
    x + y + z